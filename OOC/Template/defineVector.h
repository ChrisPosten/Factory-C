#ifndef DEFINEVECTOR_H_INCLUDED
#define DEFINEVECTOR_H_INCLUDED
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *<library that defines Object-Oriented essentials in C (Factory C)> *
 *                                                                   *
 * Copyright (C) <2023>  <Christopher Posten>                        *
 *                                                                   *
 * This program is free software: you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License       *
 * as published by the Free Software Foundation, either version 3    *
 * of the License, or any later version.                             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License for more details.                      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program.  If not, see:                    *
 * <https://www.gnu.org/licenses/>.                                  *
 * Also: <https://www.fsf.org>  (Free Software Foundation).          *
 *                                                                   *
 * The author may be reached at: <christopher.posten@factoryc.org>.  *
 * or: <jb.bee250@gmail.com>                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
    #include "../Object/Container.h"
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /**||                      C VECTOR                       || *
     *                                                           *
     *             by Willy (11/06/2018)(01/18/2021)             *
     * ||                   (01/12/2022)(01/21/2022)          || */
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * @brief c array vector template (c vector) x-macro         *
     *                                                           *
     *     includes macros to simulate a C++                     *
     *     template's type named types list                      *
     *                                                           *
     *  - - to be used with new and delete from OOC library - -  *
     *                                                           *
     *  type: int (typedef types using qualifiers or pointers)   *
     *                                                           *
     * @author willy                                             *
     * @version (2017 - 01 - 21) (2017 - 05 - 08)                *
     *          (2018 - 06 - 21) (2018 - 08 - 02)                *
     *          (2020 - 12 - 31) (2021 - 02 - 14)                *
     *          (2021 - 09 - 16)                                 *
     *                                                           *
     * TODO: copy and paste a debuggable version                 *
     *                                                           *
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     *                                                           *
     * important: these two functions must be implemented after  *
     *            the defineVector([type]) macro is used to      *
     *            generate code for the datastructure or         *
     *            new(Class) wont work (not anymore).            *
     *                                                           *
     * cstring [type]VectorType(){ return "[type]Vector"; }      *
     *                                                           *
     * cstring [type]IteratorType(){ return "[type]Iterator"; }  *
     *                                                           *
     * also: undefine then redefine the size_type macro before   *
     *       using defineVector([type]) to pick the measurement  *
     *       type for each implementation generated by the       *
     *       defineVector([type]) macro such as:                 *
     *                                                           *
     *  #undef size_type                                         *
     *  #define size_type sizeType                               *
     *  defineVector(type);                                      *
     *                                                           *
     * and so:                                                   *
     *                                                           *
     *  #undef size_type                                         *
     *  #define size_type sizeType                               *
     *  defineVector(type);                                      *
     *                                                           *
     * cstring [type]VectorType(){ return "[type]Vector"; }      *
     *                                                           *
     * cstring [type]IteratorType(){ return "[type]Iterator"; }  *
     *                                                           *
     *  is the basic pattern for generating code...  (#)         *
     *                                                           *
     *  last major update:                                       *
     *                                                           *
     *   the macros/files that include Basic in the              *
     *   name don't implement functions that encapsulate         *
     *   new(Class) or include a proper initializer function     *
     *   that new(Class) uses from the constructor.              *
     *                                                           *
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /**          proper bounds checking for unsigned:            */

    #define ifOutOfBounds( maxsize, probe, break )\
    \
        if( ( typemax(size_type) - maxsize ) > ( typemax(size_type) / 2 ) )\
        { if( flag )\
            { if( probe < ( typemax(size_type) / 2 ) ){ break; } } \
            else \
            { if( probe > ( typemax(size_type) / 2 ) ){ break; } }\
        }\
        else\
        { if( probe > maxsize - 1 )\
            { break; } }
    ///... or just check if > max - 1

    #ifndef multiplier

        #define multiplier   2

    #endif // multiplier

    #ifndef default_size

        #define default_size  255

    #endif // default_size

    #undef multiplier

    volatile static size_type multiplier = 3;

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    #define defineIterator(type)\
    \
        typedef struct Iterator(type)\
        {   Iterator base;\
    \
            type * volatile p;\
    \
        }Iterator(type);\
    \
    \
        typedef struct Iterator(type)(VirtualTable)\
        {   Iterator(VirtualTable) base;\
    \
            bool () (*prev)( Iterator(type) * );\
    \
        } Iterator(type)(VirtualTable);\
    \
                              /*virtual table object (vto)*/\
        static Iterator(type) * Iterator(type)(Init)\
        ( Iterator(type) *, .../*type * */ );\
    \
        static void Iterator(type)(Dtor)( Iterator(type) * );/*(vto)*/\
    \
        static cstring Iterator(type)(Type)();/*(vto)*/\
    \
    \
        static ctorPtr Iterator(type)(Ctor)();/*factory table class (ftc)*/\
    \
    \
        static type * Iterator(type)(Get)( Iterator(type) * );\
    \
        static bool Iterator(type)(Equal)( const Iterator(type) *, ...\
    \
                                         /*const Iterator(type) * */ );\
    \
        static bool Iterator(type)(Next)( Iterator(type) * );\
    \
        static bool Iterator(type)(Prev)( Iterator(type) * );\
    \
    \
        explicit void Iterator(type)(Dtor)( Iterator(type) * self ) { }\
    \
        explicit cstring Iterator(type)(Type)(){ return "Iterator(" #type ")"; }\
    \
    \
        static Iterator(type)(VirtualTable) \
    \
            Iterator(type)(Interface) = \
        {\
            {\
                {\
                    &Iterator(type)(Type),\
    \
                    &Iterator(type)(Init),\
    \
                    &Iterator(type)(Dtor)\
                },\
    \
                &Iterator(type)(Get),\
    \
                &Iterator(type)(Equal),\
    \
                &Iterator(type)(Next)\
            },\
    \
            &Iterator(type)(Prev)\
        };\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief initializer                                          *
    *                                                             *
    * @param self pointer                                         *
    * @param pointer to value                                     *
    *                                                             *
    * @return pointer to initialize object created using new      *
    *         (may be ignored)                                    *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit Iterator(type) * Iterator(type)(Init)\
    \
        ( Iterator(type) * self, .../*type * p */ )\
        {\
            /*if( self == nullptr ){ return nullptr; }*/\
    \
            Stack * stack = control();\
    \
            type * p = arg(stack, type*);\
    \
            self->p = p;\
    \
            return self;\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief get                                                  *
    *                                                             *
    * @param self pointer                                         *
    *                                                             *
    * @return pointer to data field position                      *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit type * Iterator(type)(Get)( Iterator(type) * self )\
        {\
            if( self->p == nullptr )\
            {\
                return nullptr;\
            }\
            return self->p;\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief equal (comparison)                                   *
    *                                                             *
    * @param self pointer                                         *
    * @param other iterator                                       *
    *                                                             *
    * @return true or false for operation success/failure         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit bool Iterator(type)(Equal)( const Iterator(type) * self, ...\
    \
        /*const Iterator(type) * other*/ )\
        {\
            Stack * stack = control();\
    \
            const Iterator(type) * other = arg(stack, const Iterator(type)*);\
    \
            if( self->p == other->p )\
            {\
                return true;\
            }\
            else\
            {\
                return false;\
            }\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief next      (may be null terminated may not be)        *
    *                                                             *
    * @param self pointer                                         *
    *                                                             *
    * @return true or false for operation success/failure         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit bool Iterator(type)(Next)( Iterator(type) * self )\
        {\
            if( self->p == nullptr )\
            {\
                return false;\
            }\
            self->p++;\
            return true;\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief back     (may be null terminated may not be)         *
    *                                                             *
    * @param self pointer                                         *
    *                                                             *
    * @return true or false for operation success/failure         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit bool Iterator(type)(Prev)( Iterator(type) * self )\
        {\
            if( self->p == nullptr )\
            {\
                return false;\
            }\
            self->p--;\
            return true;\
        }

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
            ///(see Iterator.h)
    ///#define Iterator(type) type##Iterator  //front end for the
                                          ///datatype (set)
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
     * @brief  c vector                                          *
     *                      (constructor)                        *
     * @param                 n = size                           *
     *      case 0:                                              *
     *        Vector(type)* v = new(Vector(type))(this, 0, n);   *
     *      case 1:                                              *
     *        Vector(type)* v = new(Vector(type))(this, 1, obj); *
     *      case n:                                              *
     *        Vector(type)* v = new(Vector(type))(this, n);      *
     *                                                           *
     *  note: case 1 for copy constructor                        *
     *                                                           *
     *  also: typeVector##Init concatenates to                   *
     *        Vector(type)(Init) using new                       *
     *                                                           *
     *   and: typeVector##Interface (both are required for new)  *
     *                                                           *
     *      the vectors base type is Container. therefore:       *
     *      Container * c = new (Vector(int))(this, n); is how   *
     *      you create a new instance and initialize a base      *
     *      type pointer to vector memory. look inside           *
     *      Container.h and Iterator.h for their interfaces      *
     *      Container is what i would consider to be the         *
     *      primary interface of OOC as Object is not an         *
     *      implemented structured datatype                      *
     *                                                           *
     * @return  vector object                                    *
     *                                                           *
     *                        (resize)                           *
     * @param                self, size                          *
     *                                                           *
     *      the resize function resizes the vectors array        *
     *      by allocating a new array and destroying the old     *
     *      one. a pointer inside the vector is reinitialized    *
     *      to point to the new array after each of its          *
     *      datafield positions is initialized to each of        *
     *      the old arrays datafield positions.                  *
     *                                                           *
     *      also, the vector resizes itself a multiple of its    *
     *      original size using the multiplier defined above,    *
     *      therefore redefining that macro will change the      *
     *      resize functions behavior, the size parameter given  *
     *      should be considered an estimate                     *
     *                                                           *
     * @return  true or false                                    *
     ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    #define defineBasicVector(type, comp)\
    \
        comp\
    \
        /*volatile typename(...)*/\
        typedef struct Vector(type)\
        {   Container base;\
    \
            type * volatile array;        /**[0] for array**/\
    \
            size_type length, maxsize;\
    \
        }Vector(type);\
    \
    \
        typedef struct Vector(type)(VirtualTable)\
        {   Container (VirtualTable) base;\
    \
            bool () (*resize)( Vector(type) *, .../*size_type*/ );       /*[9]*/\
    \
            bool () (*replace)( Vector(type) *, .../*size_type, type*/ );/*[10]*/\
    \
            bool () (*clear)( Vector(type) * );                          /*[11]*/\
    \
            type * (*front)( Vector(type) * );                           /*[12]*/\
    \
            type * (*back)( Vector(type) * );                            /*[13]*/\
    \
            size_type () (*max)( const Vector(type) * );                 /*[14]*/\
    \
            Iterator(type) * (*end)( const Vector(type) * );             /*[15]*/\
    \
        } Vector(type)(VirtualTable) ;\
    \
    \
        static Vector(type) * Vector(type)(Init)( Vector(type) *, ... );\
    \
        static void Vector(type)(Dtor)( Vector(type) * );\
    \
        static cstring Vector(type)(Type)();\
    \
                        /* adapter functions (stack) */\
        static bool Vector(type)(StackInsert)( Vector(type) *, .../*type*/ );\
    \
        static bool Vector(type)(QueueInsert)( Vector(type) *, .../*type*/ );\
    \
        static bool Vector(type)(NoIndexRemove)( Vector(type) * );\
    \
        static type * Vector(type)(NoIndexAt)( Vector(type) * );\
    \
    \
        static bool Vector(type)(Copy)( Vector(type) *, ... /*const Vector(type) * */ );\
    \
        static bool Vector(type)(Insert)( Vector(type) *, .../*size_type, type*/ );\
    \
        static bool Vector(type)(Remove)( Vector(type) *, .../*size_type*/ );\
    \
        static bool Vector(type)(Replace)( Vector(type) *, .../*size_type, type*/ );\
    \
        static type * Vector(type)(At)( Vector(type) *, .../*size_type*/ );\
    \
        static size_type Vector(type)(Size)( const Vector(type) * );\
    \
        static size_type Vector(type)(Max)( const Vector(type) * );\
    \
        static Iterator(type) * Vector(type)(Begin)( const Vector(type) * );\
    \
        static Iterator(type) * Vector(type)(End)( const Vector(type) * );\
    \
        static type * Vector(type)(Front)( Vector(type) * );\
    \
        static type * Vector(type)(Back)( Vector(type) * );\
    \
        static bool Vector(type)(Resize)( Vector(type) *, .../*size_type*/ );\
    \
        static bool Vector(type)(Clear)( Vector(type) * );\
    \
     /**static void * get##type##ptr ( Vector(type) * ) ; (DEMO)**/\
    \
    \
        explicit cstring Vector(type)(Type)(){ return "Vector(" #type ")"; }\
    \
    /* note: this is what it would look like were an interface declared (with 0's).
     */\
    /*  static Vector(type)(VirtualTable) Vector(type)(Interface) = \
        {\
            {\
                {\
                    &Vector(type)(Type),\

                    &Vector(type)(Init),

                    &Vector(type)(Dtor)\
                },\
    \
                &Vector(type)(Copy),\
    \
                &Vector(type)(Insert),\
    \
                &Vector(type)(Remove),\
    \
                &Vector(type)(At),\
    \
                &Vector(type)(Size),\
    \
                0\
            },\
    \
            &Vector(type)(Resize),\
    \
            &Vector(type)(Clear),\
    \
            &Vector(type)(Front),\
    \
            &Vector(type)(Back),\
    \
            &Vector(type)(Max),\
    \
            0\
        };\
    \*/\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief destructor                                           *
    *                                                             *
    * @param self pointer                                         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit void Vector(type)(Dtor)( Vector(type) * self )\
        {\
            deallocate( self->array );\
    \
            self->array     =   nullptr;\
            self->maxsize   =   0;\
            self->length    =   0;\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief add,get, rem to/from the vectors list (Stack)        *
    *   - - these are the implementations for the vectors  - -    *
    *     - - adapter container interface stored at the - -       *
    *         - -     factory table (01/16/2022)   - -            *
    *                                                             *
    *     - - this function matches the Stk and HashSet  - -      *
    * - - update: this Container will have adapters to match - -  *
    *  - -      Containers of different classes:  - -             *
    *                  - - Sequence, Adapter     - -              *
    *                                                             *
    * @param Vector(type)    self pointer                         *
    * @param (type)          value                                *
    *                                                             *
    * @return true or false for operation success/failure         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit bool Vector(type)(StackInsert)\
    \
        ( Vector(type) * self, .../*type val*/ )\
        {\
            Stack * stack = control();\
    \
            type val = arg(stack, type);\
    \
            return Vector(type)(Insert)( self, 0, val );\
        }                                   /*self->length,*/\
    \
        explicit bool Vector(type)(QueueInsert)\
    \
        ( Vector(type) * self, .../*type val*/ )\
        {\
            Stack * stack = control();\
    \
            type val = arg(stack, type);\
    \
            return Vector(type)(Insert)( self, self->length, val );\
        }                                      /*,*/\
    \
        explicit bool Vector(type)(NoIndexRemove)\
    \
        ( Vector(type) * self )\
        {\
            return Vector(type)(Remove)( self, 0 );\
        }\
    \
        explicit type * Vector(type)(NoIndexAt)\
    \
        ( Vector(type) * self )\
        {\
            return Vector(type)(At)( self, 0 );\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief add to the vectors list                              *
    *  - - re-initialize the ClassVirtualTable insert() to - -    *
    *    - - this function to use indexes from Container - -      *
    *                                                             *
    * @param Vector(type)    self pointer                         *
    * @param (size_type)     index                                *
    * @param (type)          value                                *
    *                                                             *
    * @return true or false for operation success/failure         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit bool Vector(type)(Insert)\
    \
        ( Vector(type) * self, .../*size_type index, type val*/ )\
    \
        {\
            Stack * stack = control();\
    \
            size_type index = arg(stack, size_type);\
    \
            type val = arg(stack, type);\
    \
            if( index > self->length )/* index < 0 || */\
            {\
                return false;/* call resize */\
            }\
    \
    \
            if( self->length == self->maxsize )\
            {\
                size_type newsize, maximum = typemax(size_type);\
    \
    \
                if( self->maxsize == maximum )\
                {\
                    return false;/* full vector */\
                }\
    \
    \
                if( (size_type)(self->maxsize * multiplier) < \
    \
                   (size_type)self->maxsize )\
                {\
                    newsize = maximum;\
                }\
                else\
                {\
                    newsize = self->maxsize * multiplier;\
                }\
    \
                if( !Vector(type)(Resize)(self, newsize) )\
                {\
                    return false;\
                }\
            }\
            size_type i = self->length;\
    \
    \
            while( i > index )\
            {\
                self->array[i] = self->array[i - 1]; i--;\
            }\
    \
    \
            self->array[index] = val;\
    \
    \
            self->length += 1;\
    \
            return true;\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief remove from the vectors list                         *
    *                                                             *
    * @param Vector(type)    self pointer                         *
    * @param (size_type)     index                                *
    *                                                             *
    * @return true or false for operation success/failure         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit bool Vector(type)(Remove)\
    \
        ( Vector(type) * self, .../*size_type index*/ )\
    \
        {\
            Stack * stack = control();\
    \
            size_type index = arg(stack, size_type);\
    \
            if( index >= self->length )\
            {\
                return false;\
            }\
            if( self->length == 0 )\
    \
            {\
                return false;\
            }\
            if( self->length < self->maxsize / multiplier )\
    \
            {\
                if ( !Vector(type)(Resize)(self, self->maxsize /\
    \
                    multiplier ) )\
                {\
                    return false;\
                }\
            }\
            size_type i = index;\
    \
            while( i < self->length - 1 )\
            {\
    \
                self->array[i] = self->array[i + 1]; i++;\
            }\
            self->length -= 1;\
    \
            return true;\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief get a pointer to data field pos                      *
    *                                                             *
    * @param Vector(type)    self pointer                         *
    * @param (size_type)     index                                *
    * @param (type)          value                                *
    *                                                             *
    * @return type * val                                          *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit type * Vector(type)(At)\
    \
        ( Vector(type) * self, .../*size_type index*/ )\
        {\
            Stack * stack = control();\
    \
            size_type index = arg(stack, size_type);\
    \
            if( index >= self->length )\
            {\
                return nullptr;\
            }\
            return self->array + index;\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief replace at data field pos                            *
    *                                                             *
    * @param Vector(type)    self pointer                         *
    * @param (size_type)     index                                *
    * @param (type)          value                                *
    *                                                             *
    * @return true or false for operation success/failure         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit bool Vector(type)(Replace)\
    \
        ( Vector(type) * self, .../*size_type index, type val*/ )\
        {\
            Stack * stack = control();\
    \
            size_type index = arg(stack, size_type);\
    \
            type val = arg(stack, type);\
    \
            if( index >= self->length )\
            {\
                return false;\
            }\
            self->array[index] = val;\
    \
            return true;\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief clear with fresh array                               *
    *                                                             *
    * @param self pointer                                         *
    *                                                             *
    * @return true or false for operation success/failure         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit bool Vector(type)(Clear)( Vector(type) * self )\
        {\
    \
            type* oldarray = self->array;\
    \
            self->array = (type*)allocate(\
    \
                sizeof(type) * self->maxsize);\
    \
            if( self->array == nullptr )\
            {\
                self->array = oldarray;\
    \
                return false;\
            }\
            else \
            {\
                deallocate(oldarray);\
    \
                self->length = 0;\
    \
                return true;\
            }\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief copy from object                                     *
    *                                                             *
    * @param self pointer                                         *
    * @param other object                                         *
    *                                                             *
    * @return true or false for operation success/failure         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit bool Vector(type)(Copy)( Vector(type) * self,\
    \
            .../*const Vector(type) * other*/ )\
        {\
            Stack * stack = control();\
    \
            const Vector(type) * other = arg(stack, const Vector(type)*);\
    \
            if( self != other )\
            {\
                type * array = nullptr;\
    \
                if( self->maxsize != other->maxsize )\
                {\
                    array = self->array;\
    \
                    self->array = allocate(\
    \
                        sizeof(type) * other->maxsize );\
                }\
    \
                if( self->array != nullptr )\
                {\
                    deallocate(array);\
    \
                    self->maxsize = other->maxsize;\
    \
                    self->length  = other->length;/* here */\
    \
                    size_type index;\
    \
                    for( index = 0; index < self->maxsize; index++ )\
                    {\
                        self->array[index] = other->array[index];\
                    }\
                    return true;\
                }\
                else \
    \
                if( self->array == nullptr )\
                {\
                    self->array = array;\
    \
                    return false;\
                }\
            }\
            else \
    \
            if( self == other )\
            {\
                return false;\
            }\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief resize                                               *
    *                                                             *
    * @param self pointer                                         *
    * @param (size_type) size to resize to                        *
    *                                                             *
    * @return true or false for operation success/failure         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit bool Vector(type)(Resize)\
    \
        ( Vector(type) * self, .../*size_type newsize*/ )\
        {\
            Stack * stack = control();\
    \
            size_type newsize = arg(stack, size_type);\
    \
            size_type oldsize = self->maxsize;\
    \
            type * oldarray;\
    \
            if( newsize == 0 || newsize == 1 )\
            {\
                return false;/*self->maxsize = multiplier;*/\
            }\
            if( self->maxsize == newsize )\
            {\
                return false;\
            }\
            else if( self->maxsize < newsize )\
            {\
                while( self->maxsize < newsize )\
                {\
                    if( newsize == typemax(size_type) )\
                    {\
                        self->maxsize = typemax(size_type);\
                    }\
                    else\
                    {\
                        self->maxsize = (self->maxsize * multiplier);\
                    }\
                }\
            }\
            else if( self->maxsize > newsize )\
            {\
                while( self->maxsize / multiplier > newsize )\
                {\
                    self->maxsize = (self->maxsize / multiplier);\
                }\
            }\
            oldarray = self->array;\
    \
            self->array = allocate(sizeof(type) * self->maxsize);\
    \
            if( self->array == nullptr )\
            {\
                self->array    =   oldarray;\
                self->maxsize  =   oldsize;\
                return false;\
            }\
            else\
            {\
                if( self->length > self->maxsize )\
                {\
                    self->length = self->maxsize;\
                }\
                size_type i;\
    \
                for(i = 0; i < self->length; i++)\
                {\
                    self->array[i] = oldarray[i];\
                }\
                return true;\
            }\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief demonstrate the capability of a void pointer         *
    *        with this function since a pointer                   *
    *        to any data type can be returned as a void pointer   *
    *        and since this macro generates a data structure as   *
    *        a container of any data type (template)              *
    *                                                             *
    * @param self pointer                                         *
    *                                                             *
    * @return void * (Object *)                                   *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
     /**explicit void * get##type##ptr( Vector(type) * self )\
        {\
            return self->array;\
        }**/\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief size                                                 *
    *                                                             *
    * @param (Vector(type)) self pointer                          *
    *                                                             *
    * @return (size_type) the size of initialized list            *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit size_type Vector(type)(Size)( const Vector(type) * self )\
        {\
            return self->length;\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief max                                                  *
    *                                                             *
    * @param (Vector(type)) self pointer                          *
    *                                                             *
    * @return (size_type) the size of the vector                  *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit size_type Vector(type)(Max)( const Vector(type) * self )\
        {\
            return self->maxsize;\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief front                                                *
    *                                                             *
    * @param self pointer                                         *
    *                                                             *
    * @return (type) first data field pos                         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit type * Vector(type)(Front)( Vector(type) * self )\
        {\
            if( self->length == 0 ){ return nullptr; }\
    \
            return self->array;\
        }\
    \
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief back                                                 *
    *                                                             *
    * @param self pointer                                         *
    *                                                             *
    * @return (type) last data field pos of initialized memory    *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\
        explicit type * Vector(type)(Back)( Vector(type) * self )\
        {\
            if( self->length == 0 ){ return nullptr; }\
    \
            return self->array + self->length - 1;\
        }

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /**
        defineVector( type, defineIterator(type) )

                            ==

        define(Vector)( type, define(Iterator)(type) )

                            ==

        typename(Vector)( type, typename(Iterator)(type) )
    */
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    #define Vector(type)   type##Vector    //front end
           //Vector(int) * v = new(Vector(int))(this, ...);
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /*                                                           *
     * @brief define copy for arrays                             *
     *                                                           */
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /*                    function templates                     */
    #define defineCopy(type)\
   ;\
        static void type##Copy( type *, type *, type *, type * );\
    \
        explicit void type##Copy( type * a, type * b, type * c, type * d )\
    \
        { while( a != c || b != d ){ *a = *b; a++; b++; } }

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /*                                                           *
     * @brief define fill for arrays (recursive copy)            *
     *                                                           *
     * --will not go past 65534 calls--                          *
     *                                                           */
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    #define defineFill(type)\
    \
        static void type##Fill( type *, type *, type *, type * );\
    \
        explicit void type##Fill( type * a, type * b, type * c, type * d )\
        {\
            if( a == c || b == d )\
            {\
                return true;\
            }\
            *a = *b;\
            type##Fill( ++a, ++b, c, d );\
        }

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /*                                                           *
     * @brief define mass call/procedure function for arrays     *
     *                                                           *
     * --will not go past 65534 calls--                          *
     *                                                           */
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    #define defineMap(type, name)\
    \
        static type##name( type*, type*, void(*)(type*, type*));\
    \
        explicit void type##name( type* a, type* b, void(*map)(type*, type*))\
        {\
            if( a == b )\
            {\
                return true;\
            }\
    \
            (*map)(a, b);\
    \
            type##name( ++a, b );\
        }

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    /// /// /// /// /// /// /// /// /// ///
    ///  front-end for array functions  ///
    /*   #define char(f) char##f         */
    /// /// /// /// /// /// /// /// /// ///

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    /* note: these are for the hashtables
     */
    // Iterator(Pair(Key,Value))

    #define IteratorPair(Key,Value) Key##Value##Pair##Iterator

    #define VectorPair(Key,Value) Key##Value##Pair##Vector

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /*                             __
                                  /\ \__
            __  __   ___     ___ /\__  _\    ___   ____
           /\ \/\ \ / __`\  / ___\/_/\ \/   / __`\/\  _`\
           \ \ \/ //\  __/_/\ \__/_ \ \ \/\/\ \/\ \ \ \_/
            \ \__/ \ \_____\ \_____\ \ \__/\ \____/\ \_\
             \/_/   \/_____/\/_____/  \/_/  \/___/  \/_/
                                                                 */
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    //#include "../Virtual/vTable.h"

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * @brief x-macro for the Vector(type)                       *
     *                                                           *
     *     implement the global initializer that the constructor *
     *     can point to, implement functions that encapsulate    *
     *     new(Class) and declare the interface. this is so      *
     *     the vector can properly be a lvl.1 object             *
     *                                                           *
     * @author willy                                             *
     *                                                           *
     * @version (2021 - 03 - 06)                                 *
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    #define defineVector(type, comp)\
    \
        defineVectorInit(type, defineBasicVector(type, comp))

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    #define defineVectorInit(type, comp)\
    \
        comp;\
    \
        static Iterator(type) * Vector(type)(Begin)( const Vector(type) * );\
    \
        static Iterator(type) * Vector(type)(End)( const Vector(type) * );\
    \
        static ctorPtr Vector(type)(Ctor)();\
    \
        /**                default interface               **/\
    \
        static Vector(type)(VirtualTable) \
    \
            Vector(type)(Interface) = \
        {\
            {\
                {\
                    &Vector(type)(Type), \
    \
                    &Vector(type)(Init),\
    \
                    &Vector(type)(Dtor)\
                },\
    \
                &Vector(type)(Copy),\
    \
                &Vector(type)(Insert),\
    \
                &Vector(type)(Remove),\
    \
                &Vector(type)(At),\
    \
                &Vector(type)(Size),\
    \
                &Vector(type)(Begin)\
            },\
    \
            &Vector(type)(Resize),\
    \
            &Vector(type)(Replace),\
    \
            &Vector(type)(Clear),\
    \
            &Vector(type)(Front),\
    \
            &Vector(type)(Back),\
    \
            &Vector(type)(Max),\
    \
            &Vector(type)(End) \
        };\
        explicit ctorPtr Vector(type)(Ctor)()\
    \
            {return new(Vector(type));} \
    \
    \
        explicit Vector(type) * Vector(type)(Init) \
    \
            ( Vector(type) * self, ... )\
        {\
            if( self == nullptr ){ return nullptr; }\
    \
            Stack * stack = control();/*control();*//**control()*/\
    \
            size_t c = arg(stack, size_t);\
    \
            switch(c)\
            {\
                case 0:    ; /* parameters: case, maxsize */\
    \
                    /* note: this declaration is to prevent possible
                     *       mis-assembly when handling the function
                     *       arguments stack for a factory function.
                     */\
                    size_type maxsize = arg(stack, size_type);\
    \
                    self->maxsize = maxsize;/*init*/\
    \
                    if( !self->maxsize )\
                    {\
                        self->array = nullptr;\
                    }\
                    else \
                    {\
                        self->array = (type*)allocate(\
    \
                            sizeof(type) * self->maxsize );\
    \
                        if( self->array == nullptr ){ return nullptr; }\
                    }\
                    self->length = 0;\
    \
                break;\
                case 1:    ; /* parameters: case, obj */\
    \
                    /* note: here too.
                     */\
                    Vector(type) * other = arg(stack, Vector(type)*);\
    \
                    /*self->maxsize = 0;*/\
    \
                    self->array = (type*)allocate(\
    \
                        sizeof(type) * other->maxsize );\
    \
                    if( self->array == nullptr ){ return nullptr; }\
    \
                    self->maxsize = other->maxsize;\
    \
                    Vector(type)(Copy)(self, other);\
    \
                break;\
                default:    /* parameters: case = maxsize */\
    \
                    self->maxsize = c;\
    \
                    self->array = (type*)allocate(\
    \
                        sizeof(type) * self->maxsize );\
    \
                    if( self->array == nullptr ){ return nullptr; }\
    \
                    self->length = 0;\
    \
                break;\
            }\
    \
            return self;\
        }\
    \
        explicit Iterator(type) * Vector(type)(Begin) \
    \
            ( const Vector(type) * self )\
        {\
            if( self->length == 0 ){ return nullptr; }\
    \
            return new(Iterator(type))( this, \
    \
                    virtual(self, Vector(type))->front(this) );\
        }\
    \
        explicit Iterator(type) * Vector(type)(End) \
    \
            ( const Vector(type) * self )\
        {\
            if( self->length == 0 ){ return nullptr; }\
    \
            return new(Iterator(type))( this, \
    \
                    virtual(self, Vector(type))->back(this) + 1 );\
        }

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    // define Stack(Vector(type))(Init) Vector(type)(Init)

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * @brief x-macro for adapter interfaces                     *
     *                                                           *
     *     these are for the adapter(Class, Adapter) macro       *
     *     so: adapter(Stack, Vector(int))(this, ...); i must    *
     *     note that these do not use the adapter table as the   *
     *     the vector is not an object adapter to another        *
     *     object.                                               *
     *                                                           *
     * @author willy                                             *
     *                                                           *
     * @version (2023 - 14 - 01)                                 *
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    #define defineStackVector(type)\
    \
            static ctorPtr Stack(Vector(type))(Ctor)();\
    \
            static Vector(type)(VirtualTable) \
    \
                Stack(Vector(type))(Interface) = \
        {\
            {\
                {\
                    &Vector(type)(Type), \
    \
                    &Vector(type)(Init),\
    \
                    &Vector(type)(Dtor)\
                },\
    \
                &Vector(type)(Copy),\
    \
                &Vector(type)(StackInsert),\
    \
                &Vector(type)(NoIndexRemove),\
    \
                &Vector(type)(NoIndexAt),\
    \
                &Vector(type)(Size),\
    \
                &Vector(type)(Begin) \
            },\
    \
            &Vector(type)(Resize),\
    \
            &Vector(type)(Replace),\
    \
            &Vector(type)(Clear),\\
    \
            &Vector(type)(Front),\
    \
            &Vector(type)(Back),\
    \
            &Vector(type)(Max),\
    \
            &Vector(type)(End) \
        };\
        explicit ctorPtr Stack(Vector(type))(Ctor)()\
    \
            {return adapter(Stck, Vector(type));}

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    #define defineQueueVector(type)\
    \
        static ctorPtr Queue(Vector(type))(Ctor)();\
    \
        static Vector(type)(VirtualTable) \
    \
            Queue(Vector(type))(Interface) = \
        {\
            {\
                {\
                    &Vector(type)(Type), \
    \
                    &Vector(type)(Init),\
    \
                    &Vector(type)(Dtor)\
                },\
    \
                &Vector(type)(Copy),\
    \
                &Vector(type)(StackInsert),\
    \
                &Vector(type)(NoIndexRemove),\
    \
                &Vector(type)(NoIndexAt),\
    \
                &Vector(type)(Size),\
    \
                &Vector(type)(Begin) \
            },\
    \
            &Vector(type)(Resize),\
    \
            &Vector(type)(Replace),\
    \
            &Vector(type)(Clear),\
    \
            &Vector(type)(Front),\
    \
            &Vector(type)(Back),\
    \
            &Vector(type)(Max),\
    \
            &Vector(type)(End) \
        };\
        explicit ctorPtr Queue(Vector(type))(Ctor)()\
    \
            {return adapter(Queue, Vector(type));}

    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

    //#include "defineVector.h"

    # define Stack(Member)Stack ## Member
     # define StackVector(type)Stack##type##Vector

    # define Queue(Member)Queue ## Member
     # define QueueVector(type)Queue##type##Vector

    //# define StackVector(Member)StackVector ## Member
    //# define QueueVector(Member)QueueVector ## Member

    /* note: this is needed for a class that uses the above interfaces
     */
    #if 0
        #define StackVectorClass(Member)\
            StackVectorClass ## Member
    #endif // 0 FOR_INST

    //#include "../Factory/fTable.h"
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /**||                  C FACTORY VECTOR                   || *
     *                                                           *
     *                   by Willy (02/11/2022)(01/14/2023)       *
     * ||                         (01/15/2023)                || */
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/
    /*                                                           *
     *     this is the factory table class implementation so     *
     *     the vector and its iterator can be lvl.2 objects      *
     *     or factory objects just as long as they are           *
     *     registered after they are typenamed.                  *
     *                                                           */
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/

    #define defineFactoryIterator(type, comp)\
    \
        /*defineIterator(type, comp)*/\
        comp  ;\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  methods table registration (virtual heap)         *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static Virtual\
    \
            Iterator(type)(VirtualHeap)[seven] = \
      /*a b c d e f g h i j k l m n o p q r s t u v w x y z*/\
        {\
            {"dtor", 2, &Iterator(type)(Dtor)  \
            ,"void(*)(Iterator("#type")*)"                        },\
            {"equal",4, &Iterator(type)(Equal) \
            ,"bool()(*)(const Iterator("#type")*,const "#type"*)" },\
            {"get",  3, &Iterator(type)(Get)   \
            ,#type"*(*)(Iterator("#type")*)"                      },\
            {"init", 1, &Iterator(type)(Init)  \
            ,"Iterator("#type")*(*)(Iterator("#type")*,"#type"*)" },\
            {"next", 5, &Iterator(type)(Next)  \
            ,"bool()(*)(Iterator("#type")*)"                      },\
            {"prev", 6, &Iterator(type)(Prev)  \
            ,"bool()(*)(Iterator("#type")*)"                      },\
            {"type", 0, &Iterator(type)(Type)  \
            ,"cstring(*)()"                                       },\
    \
        {"",0,0,""}, };\
        static Virtual *\
        typename(SubFactoryMethod)(Iterator(type),Virtual,Virtual,0,6);\
    \
    \
        static struct class(VirtualHeap)\
            Iterator(type)(Virtual) = \
    \
        { &class(VirtualHeap)(Type),&Iterator(type)(VirtualSearch), \
           Iterator(type)(VirtualHeap) };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  data member table registration (complex heap)     *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static Complex \
    \
            Iterator(type)(ComplexHeap)[one] = \
            { { "p", 0, sizeof(type*), #type"*" },\
            { "", 0, 0, "" }, };\
        static Complex *\
        typename(SubFactoryMethod)(Iterator(type),Complex,Complex,0,0);\
    \
    \
        static struct class(ComplexHeap)\
    \
            Iterator(type)(Complex) = \
        { &class(ComplexHeap)(Type), &Iterator(type)(ComplexSearch),\
        Iterator(type)(ComplexHeap) };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  inheritance table registration (polymorph heap)   *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static Polymorph  /**Table( Name, Offset, Offset )**/\
    \
            Iterator(type)(PolymorphHeap)[two] =\
    \
        {/**A B C D E F G H I J K L M N O P Q R S T U V W X Y Z**/\
            { "Iterator",            0,              0, "" },\
            { "class",               0,              0, "" },\
            { "", 0, 0, "" }\
        };static Polymorph *\
        typename(SubFactoryMethod)(Iterator(type),Polymorph,Polymorph,0,1);\
    \
    \
        static struct class(PolymorphHeap)\
    \
            Iterator(type)(Polymorph) = \
    \
        { &class(PolymorphHeap)(Type),\
    \
          &Iterator(type)(PolymorphSearch),\
    \
           Iterator(type)(PolymorphHeap) };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  instance table registration (factory table)       *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        explicit ctorPtr Iterator(type)(Ctor)()\
    \
            {return new(Iterator(type));}\
    \
    \
        static struct class(FactoryTable)\
    \
            Iterator(type)(Factory) = \
    \
        { &class(FactoryTable)(Type), &Iterator(type)(Ctor), 0 } ;\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  input-output table registration (console table)   *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static int Iterator(type)(ConsoleOut)(const Iterator(type) *, ...);\
    \
        static struct class(ConsoleTable)\
    \
            Iterator(type)(Console) = \
    \
        { &class(ConsoleTable)(Type), 0, &Iterator(type)(ConsoleOut) };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  input-output table registration (standard table)  *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static int Iterator(type)(StandardOut)(const Iterator(type) *, ...);/*char * */\
    \
        static struct class(StandardTable)\
    \
            Iterator(type)(Standard) = \
    \
        { &class(StandardTable)(Type), 0, &Iterator(type)(StandardOut) };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  input-output table registration (file table)      *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static int Iterator(type)(FileOut)(const Iterator(type) *, ...);/*File * */\
    \
        static struct class(FileTable)\
    \
            Iterator(type)(File) = \
    \
        { &class(FileTable)(Type), 0, &Iterator(type)(FileOut) };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  registration list security interface              *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static struct pass(SecurityHeap)\
    \
            Iterator(type)(Security) = \
    \
        { { & pass(SecurityHeap)(Type), 0,/*note: 0 for factory method for set
                                                 of available subfactory methods*/\
            0 /*Iterator(type)(InterfaceHeap)*/ },\
    \
            0 /*& Iter(Security)(ID)*/, 0 };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  class interface heap and class factory method     *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static Interface Iterator(type)\
    \
            (InterfaceHeap)[nine] = \
    \
        {/**A B C D E F G H I J K L M N O P Q R S T U V W X Y Z**/\
            &Iterator(type)(Interface),\
    \
            &Iterator(type)(Complex),   /*+sub*/\
    \
            &Iterator(type)(Console),\
    \
            &Iterator(type)(Factory),\
    \
            &Iterator(type)(File),\
    \
            &Iterator(type)(Polymorph), /*+sub*/\
    \
            &Iterator(type)(Standard),\
    \
            &Iterator(type)(Virtual),   /*+sub (class(...))*/\
    \
            &Iterator(type)(Security),  /*pass(...) 0xffffffff (passnum) */\
    \
            nullptr/* */\
        } ;\
        static Interface \
        typename(ClassFactoryMethod)(Iterator(type),0,8);/*-1*/\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  class setup and class abort                       *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static void typename(Setup)(Iterator(type))\
        {((Interface)&Iterator(type)(Security))\
        [2] = Iterator(type)(InterfaceHeap) ;}\
    \
        static void typename(Abort)(Iterator(type)){}

    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/
    #if 0
    explicit int Iterator(type)(ConsoleOut)
    (const Iterator(type) * self, ...){}

    explicit int Iterator(type)(StandardOut)
    (const Iterator(type) * self, ...){}

    explicit int Iterator(type)(FileOut)
    (const Iterator(type) * self, ...){}
    #endif // 0 MUST_IMPLEMENT_AFTER_TYPENAME

    #if 0
        #define SecurityIterator(Member) SecurityIterator ## Member
        static cstring typename(PassNumber)(Iterator, Security);
    #endif // 0 INCLUDED_TOO_EARLY
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/

    #define defineFactoryVector(type, comp)\
    \
        /*defineVector(type, comp)*/\
        comp  ;\
    \
        /*static ctorPtr Vector(type)(Ctor)(void) ;\
    \
        explicit ctorPtr Vector(type)(Ctor)(void)\
    \
            { return new(Vector(type)); } */\
    \
    \
        static struct class(FactoryTable)\
    \
            Vector(type)(Factory) =\
    \
        {\
            &class(FactoryTable)(Type),\
    \
            &Vector(type)(Ctor),\
    \
            0 \
        };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  methods table registration (virtual heap)         *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static Virtual\
    \
            Vector(type)(VirtualHeap)[sixteen] = \
        {/**A B C D E F G H I J K L M N O P Q R S T U V W X Y Z**/\
          { "at",          6,        &Vector(type)(At)\
          ,#type"*(*)(Vector("#type")*,size_type)"                },\
          { "back",        13,       &Vector(type)(Back)\
          ,#type"*(*)(Vector("#type")*)"                          },\
          { "begin",       8,        &Vector(type)(Begin)\
          ,"Iterator("#type")*(*)(const Vector("#type")*)"        },\
          { "clear",       11,       &Vector(type)(Clear)\
          ,"bool()(*)(Vector("#type")*)"                          },\
          { "copy",        3,        &Vector(type)(Copy)\
          ,"bool()(*)(Vector("#type")*,const Vector("#type")*)"   },\
          { "dtor",        2,        &Vector(type)(Dtor)\
          ,"void(*)(Vector("#type")*)"                            },\
          { "end",         15,       &Vector(type)(End)\
          ,"Iterator("#type")*(*)(const Vector("#type")*)"        },\
          { "front",       12,       &Vector(type)(Front)\
          ,#type"*(*)(Vector("#type")*)"                          },\
          { "init",        1,        &Vector(type)(Init)\
          ,"Vector("#type")*(*)(Vector("#type")*,...)"            },\
          { "insert",      4,        &Vector(type)(Insert)\
          ,"bool()(*)(Vector("#type")*,size_type,"#type")"        },\
          { "max",         14,       &Vector(type)(Max)\
          ,"size_type()(*)(const Vector("#type")*)"               },\
          { "remove",      5,        &Vector(type)(Remove)\
          ,"bool()(*)(Vector("#type")*,size_type)"                },\
          { "replace",     10,       &Vector(type)(Replace)\
          ,"bool()(*)(Vector("#type")*,size_type,type)"           },\
          { "resize",      9,        &Vector(type)(Resize)\
          ,"bool()(*)(Vector("#type")*,size_type)"                },\
          { "size",        7,        &Vector(type)(Size)\
          ,"size_type()(*)(const Vector(type)*)"                  },\
          { "type",        0,        &Vector(type)(Type)\
          ,"cstring(*)()"                                         },\
    \
          { "", 0, 0, "" }\
        };\
        static Virtual * \
        typename(SubFactoryMethod)(Vector(type),Virtual,Virtual,0,15) ;\
    \
    \
        static struct class(VirtualHeap)\
    \
            Vector(type)(Virtual) = \
    \
        {\
            &class(VirtualHeap)(Type),\
    \
            &Vector(type)(VirtualSearch),\
    \
             Vector(type)(VirtualHeap)\
        };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  data member table registration (complex heap)     *
     *                                                           *
     * - - this will malfunction if size_type anything other than*
     * a size_t or a pointer size. you can always re-init the    *
     * table here from a class setup function/method or program  *
     * constructor - -                                           *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static Complex  /**Table( Name, Offset, Offset, Type )**/\
    \
            Vector(type)(ComplexHeap)[three] =\
    \
        {/**A B C D E F G H I J K L M N O P Q R S T U V W X Y Z**/\
            { "array",       0,     sizeof(void*),      #type"*"    },\
            { "length",      1,     sizeof(size_type),  "size_type" },\
            { "maxsize",     2,     sizeof(size_type),  "size_type" },\
    \
            { "", 0, 0, "" }\
        };static Complex *\
        typename(SubFactoryMethod)(Vector(type),Complex,Complex,0,2);\
    \
    \
        static struct class(ComplexHeap)\
    \
            Vector(type)(Complex) = \
    \
        { &class(ComplexHeap)(Type), \
        &Vector(type)(ComplexSearch), Vector(type)(ComplexHeap) };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  inheritance table registration                    *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static Polymorph  /**Table( Name, Offset, Offset, Type )*/\
    \
            Vector(type)(PolymorphHeap)[two] = \
    \
        {/**A B C D E F G H I J K L M N O P Q R S T U V W X Y Z*/\
            { "Container",              0,          0, "" },\
            { "class",                  0,          0, "" },\
    \
            { "", 0, 0, "" }\
        };\
    \
    \
        static Polymorph * typename(SubFactoryMethod)\
            ( Vector(type), Polymorph, Polymorph, 0, 1 );\
    \
    \
        static struct class(PolymorphHeap)\
    \
            Vector(type)(Polymorph) =\
    \
        {\
            &class(PolymorphHeap)(Type),\
    \
            &Vector(type)(PolymorphSearch),\
    \
             Vector(type)(PolymorphHeap) \
        };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  console io                                        *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static int Vector(type)(ConsoleIn)( Vector(type) *, ... );\
    \
        static int Vector(type)(ConsoleOut)( const Vector(type) *, ... );\
    \
        static struct class(ConsoleTable)\
    \
            Vector(type)(Console) = \
    \
        {   &class(ConsoleTable)(Type),\
    \
            &Vector(type)(ConsoleIn),\
    \
            &Vector(type)(ConsoleOut)   };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  file io                                           *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static int Vector(type)(FileIn) ( Vector(type) *, ... );\
    \
        static int Vector(type)(FileOut) ( const Vector(type) *, ... );\
    \
        static class(FileTable)\
    \
            Vector(type)(File) = \
    \
        {   &class(FileTable)(Type),\
    \
            &Vector(type)(FileIn),\
    \
            &Vector(type)(FileOut)   };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  standard io                                       *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static int Vector(type)(StandardIn) ( Vector(type) *, ... );\
    \
        static int Vector(type)(StandardOut) ( const Vector(type) *, ... );\
    \
        static class(StandardTable)\
    \
            Vector(type)(Standard) = \
    \
        {   &class(StandardTable)(Type),\
    \
            &Vector(type)(StandardIn),\
    \
            &Vector(type)(StandardOut)   };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  security interface for registration list          *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static struct pass(SecurityHeap)\
    \
            Vector(type)(Security) = \
    \
        { { & pass(SecurityHeap)(Type), 0,/*note: 0 for factory method for set
                                                 of available subfactory methods*/\
            0 /*Vector(type)(InterfaceHeap)*/ },\
    \
            0 /*& Vector(Security)(ID)*/, 0 };\
    \
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    /**                                                          *
     * @brief  class factory method + class interface heap       *
     *                                                           */\
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/\
    \
        static Interface Vector(type)(InterfaceHeap)[nine] = \
        {/**A B C D E F G H I J K L M N O P Q R S T U V W X Y Z*/\
            &Vector(type)(Interface),\
    \
            &Vector(type)(Complex),\
    \
            &Vector(type)(Console),\
    \
            &Vector(type)(Factory),\
    \
            &Vector(type)(File),\
    \
            &Vector(type)(Polymorph),\
    \
            &Vector(type)(Standard),\
    \
            &Vector(type)(Virtual),\
    \
            &Vector(type)(Security),\
    \
            nullptr /*(null termination required)*/ };\
    \
        /**
         * @brief class factory method (Factory C)
         */\
        static Interface typename(ClassFactoryMethod)(Vector(type),0,8);\
    \
    \
        static void typename(Setup)(Vector(type)) \
        {((Interface)&Vector(type)(Security))\
        [2] = Vector(type)(InterfaceHeap) ;\
        register(Iterator(type));}\
    \
        static void typename(Abort)(Vector(type)) {drop(Iterator(type));}

    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/
    #if 0
    explicit int Vector(type)(ConsoleIn)
    (Vector(type) * self, ...){}
    explicit int Vector(type)(ConsoleOut)
    (const Vector(type) * self, ...){}

    explicit int Vector(type)(StandardIn)
    (Vector(type) * self, ...){}
    explicit int Vector(type)(StandardOut)
    (const Vector(type) * self, ...){}

    explicit int Vector(type)(FileIn)
    (Vector(type) * self, ...){}
    explicit int Vector(type)(FileOut)
    (const Vector(type) * self, ...){}
    #endif // 0 MUST_IMPLEMENT_AFTER_TYPENAME

    #if 0
        #define SecurityVector(Member) SecurityVector ## Member
        static cstring typename(PassNumber)(Vector, Security);
    #endif // 0 INCLUDED_TOO_EARLY
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/

   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/
    /** DEBUG VERSION        DEBUG VERSION        DEBUG VERSION **/
    /*/ /// /// /// /// /// /// /// /// /// /// /// /// /// /// /*/
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/

   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
    #if 0 // 1 DEBUG

        typedef struct Iterator(ClassClassVirtualTablePair)
        {   Iterator base;

            ClassClassVirtualTablePair * volatile p;

        }Iterator(ClassClassVirtualTablePair);


        typedef struct Iterator(ClassClassVirtualTablePair)(VirtualTable)
        {   Iterator(VirtualTable) base;

            bool () (*prev)( Iterator(ClassClassVirtualTablePair) * );

        } Iterator(ClassClassVirtualTablePair)(VirtualTable);

                              /*virtual table object (vto)*/
        static Iterator(ClassClassVirtualTablePair) * Iterator(ClassClassVirtualTablePair)(Init)
        ( Iterator(ClassClassVirtualTablePair) *, .../*ClassClassVirtualTablePair * */ );

        static void Iterator(ClassClassVirtualTablePair)(Dtor)( Iterator(ClassClassVirtualTablePair) * );/*(vto)*/

        static cstring Iterator(ClassClassVirtualTablePair)(Type)();/*(vto)*/


        static ctorPtr Iterator(ClassClassVirtualTablePair)(Ctor)();/*factory table class (ftc)*/


        static ClassClassVirtualTablePair * Iterator(ClassClassVirtualTablePair)(Get)( Iterator(ClassClassVirtualTablePair) * );

        static bool Iterator(ClassClassVirtualTablePair)(Equal)( const Iterator(ClassClassVirtualTablePair) *, ...

                                         /*const Iterator(ClassClassVirtualTablePair) * */ );

        static bool Iterator(ClassClassVirtualTablePair)(Next)( Iterator(ClassClassVirtualTablePair) * );

        static bool Iterator(ClassClassVirtualTablePair)(Prev)( Iterator(ClassClassVirtualTablePair) * );


        explicit void Iterator(ClassClassVirtualTablePair)(Dtor)( Iterator(ClassClassVirtualTablePair) * self ) { }

        explicit cstring Iterator(ClassClassVirtualTablePair)(Type)(){ return "Iterator(ClassClassVirtualTablePair)"; }


        static Iterator(ClassClassVirtualTablePair)(VirtualTable)

            Iterator(ClassClassVirtualTablePair)(Interface) =
        {
            {
                {
                    &Iterator(ClassClassVirtualTablePair)(Type),

                    &Iterator(ClassClassVirtualTablePair)(Init),

                    &Iterator(ClassClassVirtualTablePair)(Dtor)
                },

                &Iterator(ClassClassVirtualTablePair)(Get),

                &Iterator(ClassClassVirtualTablePair)(Equal),

                &Iterator(ClassClassVirtualTablePair)(Next)
            },

            &Iterator(ClassClassVirtualTablePair)(Prev)
        };
        explicit ctorPtr Iterator(ClassClassVirtualTablePair)(Ctor)()
    #if 0
            {return new(Iterator(ClassClassVirtualTablePair));}
    #else
            {
                return (Iterator(ClassClassVirtualTablePair)*)VirtualTable(Interface).insert(


                vtable, vstk, (Iterator(ClassClassVirtualTablePair)*)allocate(sizeof(Class)),


                & Iterator(ClassClassVirtualTablePair)(Interface), & Iterator(ClassClassVirtualTablePair)(Init) );
            }
    #endif // 0
   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief initializer                                          *
    *                                                             *
    * @param self pointer                                         *
    * @param pointer to value                                     *
    *                                                             *
    * @return pointer to initialize object created using new      *
    *         (may be ignored)                                    *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
        explicit Iterator(ClassClassVirtualTablePair) * Iterator(ClassClassVirtualTablePair)(Init)

        ( Iterator(ClassClassVirtualTablePair) * self, .../*ClassClassVirtualTablePair * p */ )
        {
            /*if( self == nullptr ){ return nullptr; }*/

            Stack * stack = control();

            ClassClassVirtualTablePair * p = arg(stack, ClassClassVirtualTablePair*);

            self->p = p;

            return self;
        }

   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief get                                                  *
    *                                                             *
    * @param self pointer                                         *
    *                                                             *
    * @return pointer to data field position                      *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
        explicit ClassClassVirtualTablePair * Iterator(ClassClassVirtualTablePair)(Get)( Iterator(ClassClassVirtualTablePair) * self )
        {
            if( self->p == nullptr )
            {
                return nullptr;
            }
            return self->p;
        }

   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief equal (comparison)                                   *
    *                                                             *
    * @param self pointer                                         *
    * @param other iterator                                       *
    *                                                             *
    * @return true or false for operation success/failure         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
        explicit bool Iterator(ClassClassVirtualTablePair)(Equal)( const Iterator(ClassClassVirtualTablePair) * self, ...

        /*const Iterator(ClassClassVirtualTablePair) * other*/ )
        {
            Stack * stack = control();

            const Iterator(ClassClassVirtualTablePair) * other = arg(stack, const Iterator(ClassClassVirtualTablePair)*);

            if( self->p == other->p )
            {
                return true;
            }
            else
            {
                return false;
            }
        }

   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief next      (may be null terminated may not be)        *
    *                                                             *
    * @param self pointer                                         *
    *                                                             *
    * @return true or false for operation success/failure         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
        explicit bool Iterator(ClassClassVirtualTablePair)(Next)( Iterator(ClassClassVirtualTablePair) * self )
        {
            if( self->p == nullptr )
            {
                return false;
            }
            self->p++;
            return true;
        }

   /** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
    * @brief back     (may be null terminated may not be)         *
    *                                                             *
    * @param self pointer                                         *
    *                                                             *
    * @return true or false for operation success/failure         *
    ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
        explicit bool Iterator(ClassClassVirtualTablePair)(Prev)( Iterator(ClassClassVirtualTablePair) * self )
        {
            if( self->p == nullptr )
            {
                return false;
            }
            self->p--;
            return true;
        }
    #endif // 0 DEBUG 1
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///
    /*    clipboard

            - - don't forget to include an adapter table
                to the registration list for the vector to be
                used as a stack or a queue (table for both)

            - - consider even using an adapter table since the
                vector wont be an adapter for something else
                so maybe forget that it needs an adapter table
                and just put a container interface in the
                registration list and swap them, (it might be
                tricky swapping them from there) i almost think
                it cant be done from where the class factory
                method returns a double pointer, consider that
                a good thing for when it comes to information
                hiding, just that there does need to be an adapter
                table... at the same time it doesnt need the adapter
                constructor because its not an adapter, so = 0


            - -

     */
    /// /// /// /// /// /// /// /// /// /// /// /// /// /// /// ///

                                                             //CWP
#endif // DEFINEVECTOR_H_INCLUDED
